<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>iOS/Android 通用冰凍魔法</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 10; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0,0,0,0.5);
            transition: opacity 0.5s;
        }
        
        #start-btn {
            padding: 15px 40px; font-size: 1.2rem; font-weight: bold;
            background: linear-gradient(135deg, #00c6ff, #0072ff); color: white;
            border: 2px solid white; border-radius: 30px; cursor: pointer;
            box-shadow: 0 0 15px #00c6ff;
        }

        #status {
            margin-top: 20px; color: #fff; text-align: center; max-width: 80%;
            line-height: 1.5; text-shadow: 0 0 5px black;
        }

        /* 隱藏的影片元素 */
        #video-feed { position: absolute; top: 0; left: 0; display: none; }
    </style>
</head>
<body>

    <audio id="sound-freeze" src="freeze.mp3" preload="auto"></audio>

    <div id="ui-layer">
        <button id="start-btn">開始冰凍魔法 (iOS/Android)</button>
        <div id="status">請允許相機與動作偵測權限<br>點擊螢幕即可發射冰凍魔法</div>
    </div>

    <video id="video-feed" autoplay playsinline webkit-playsinline muted></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/DeviceOrientationControls.js"></script>

    <script>
        let camera, scene, renderer, controls;
        let video, videoTexture;
        let snowSystem;
        const iceMeshes = [];
        const startBtn = document.getElementById('start-btn');
        const uiLayer = document.getElementById('ui-layer');
        const statusText = document.getElementById('status');
        const freezeSound = document.getElementById('sound-freeze');

        startBtn.addEventListener('click', async () => {
            // 1. 請求 iOS 動作感測權限 (關鍵步驟)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        startAR();
                    } else {
                        statusText.innerText = "需要動作感測權限才能運作";
                    }
                } catch (error) {
                    console.error(error);
                    // 如果不是 iOS 13+ 或非 HTTPS，直接嘗試啟動
                    startAR(); 
                }
            } else {
                // Android 或舊版 iOS 直接啟動
                startAR();
            }
        });

        async function startAR() {
            statusText.innerText = "正在啟動相機...";
            try {
                // 2. 啟動後鏡頭
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 } 
                    }, 
                    audio: false 
                });
                
                video = document.getElementById('video-feed');
                video.srcObject = stream;
                video.play();
                
                video.onloadedmetadata = () => {
                    uiLayer.style.display = 'none'; // 隱藏選單
                    initThreeJS();
                };
            } catch (err) {
                statusText.innerText = "無法開啟相機，請確認是用 HTTPS 網址且允許權限。";
                console.error(err);
            }
        }

        function initThreeJS() {
            // --- 場景設置 ---
            scene = new THREE.Scene();
            
            // 設定相機 (FOV 75, 讓視野廣一點)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // --- 關鍵：將相機畫面設為背景 ---
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            scene.background = videoTexture;

            // --- 控制器：使用陀螺儀 ---
            // 這會讓相機隨著手機轉動而轉動
            controls = new THREE.DeviceOrientationControls(camera);

            // --- 燈光 ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(0, 10, 0);
            scene.add(dirLight);

            // --- 創建粒子與監聽點擊 ---
            createSnow();
            window.addEventListener('click', castIceMagic);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        // --- 發射冰凍魔法 ---
        function castIceMagic() {
            // 播放音效
            const sound = freezeSound.cloneNode();
            sound.volume = 0.8;
            sound.play().catch(e=>{});

            // 1. 生成圓形冰塊材質 (程式碼繪製，解決方塊問題)
            const iceMat = new THREE.MeshPhongMaterial({
                map: createIceTexture(),
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                shininess: 100,
                color: 0xddeeff,
                emissive: 0x002244
            });

            // 2. 建立冰塊
            const geometry = new THREE.CircleGeometry(0.5 + Math.random() * 0.5, 32);
            const ice = new THREE.Mesh(geometry, iceMat);

            // 3. 計算位置：放在相機前方 3 公尺處
            // 獲取相機正前方的方向向量
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            // 位置 = 相機位置 + 方向 * 距離
            ice.position.copy(camera.position).add(direction.multiplyScalar(3));
            
            // 讓冰塊永遠面向相機
            ice.lookAt(camera.position);
            
            // 隨機旋轉一點角度增加自然感
            ice.rotation.z = Math.random() * Math.PI;

            // 動畫初始狀態
            ice.scale.set(0,0,0);
            ice.userData = { targetScale: 1.0, currentScale: 0.0 };

            scene.add(ice);
            iceMeshes.push(ice);
        }

        // --- 解決雪花方塊問題：用 Canvas 畫一個圓形光暈 ---
        function createSnowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            
            return new THREE.CanvasTexture(canvas);
        }

        // --- 繪製冰塊紋理 ---
        function createIceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // 冰裂紋
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for(let i=0; i<8; i++) {
                ctx.moveTo(64, 64);
                ctx.lineTo(Math.random()*128, Math.random()*128);
            }
            ctx.stroke();

            // 邊緣暈染
            const grad = ctx.createRadialGradient(64,64,20, 64,64,60);
            grad.addColorStop(0, 'rgba(200, 240, 255, 0.2)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,128);
            
            return new THREE.CanvasTexture(canvas);
        }

        function createSnow() {
            const geom = new THREE.BufferGeometry();
            const vertices = [];
            
            // 在一個很大的球體空間內產生雪花
            for(let i=0; i<1500; i++) {
                vertices.push((Math.random() - 0.5) * 20); // X
                vertices.push((Math.random() - 0.5) * 20); // Y
                vertices.push((Math.random() - 0.5) * 20); // Z
            }
            
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const mat = new THREE.PointsMaterial({
                size: 0.2,
                map: createSnowTexture(), // 使用畫好的圓點
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            snowSystem = new THREE.Points(geom, mat);
            scene.add(snowSystem);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 更新陀螺儀控制器
            if(controls) controls.update();

            // 更新雪花 (讓它一直落下)
            if(snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                for(let i=1; i<positions.length; i+=3) {
                    positions[i] -= 0.02; // Y軸下降
                    if(positions[i] < -10) positions[i] = 10; // 循環
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }

            // 更新冰塊動畫 (變大)
            iceMeshes.forEach(ice => {
                if(ice.userData.currentScale < ice.userData.targetScale) {
                    ice.userData.currentScale += 0.1;
                    const s = ice.userData.currentScale;
                    ice.scale.set(s, s, s);
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
