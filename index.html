<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR å†°éœœé ˜ä¸» - çµ‚æ¥µè”“å»¶ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; color: #e0ffff; 
            text-shadow: 0 0 8px #00ffff; pointer-events: none; z-index: 10;
            background: rgba(0,0,0,0.5); padding: 15px 0; border-bottom: 1px solid #00ffff;
        }
        #ar-button-container button {
            background-color: rgba(0, 190, 255, 0.8) !important;
            border: 2px solid white !important; border-radius: 25px !important;
            font-weight: bold; box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="info">
        <span style="font-size:1.4em; font-weight:bold">ğŸ§Š çµ‚æ¥µå†°éœœé­”æ³•</span><br>
        <small>iOS è«‹ä½¿ç”¨ WebXR Viewer / Android ä½¿ç”¨ Chrome</small><br>
        æƒæè¡¨é¢å‡ºç¾æº–å¿ƒå¾Œï¼Œé»æ“Šæ–½æ”¾è”“å»¶å†°éœœ
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { ARButton } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/webxr/ARButton.js';

        let camera, scene, renderer, controller;
        let reticle, hitTestSource = null, hitTestSourceRequested = false;
        
        // --- ç‰¹æ•ˆç³»çµ±è®Šæ•¸ ---
        let snowSystem, mistSystem;
        let iceTexture, mistTexture;
        // å„²å­˜æ­£åœ¨ç”Ÿé•·çš„å†°éœœäº‹ä»¶
        const growingIceEvents = []; 
        // å„²å­˜æ‰€æœ‰å†°å¡Š mesh ä»¥ä¾¿æ›´æ–°å‹•ç•«
        const allIceMeshes = [];
        
        let audioCtx; // éŸ³æ•ˆ Context

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // ç’°å¢ƒå…‰èˆ‡é­”æ³•å…‰
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xaabbff, 1);
            dirLight.position.set(0, 5, 2);
            scene.add(dirLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, opacity: 0.8, transparent: true })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // é å…ˆç”Ÿæˆç´‹ç†
            iceTexture = generateFrostTexture();
            mistTexture = generateMistTexture();

            // åˆå§‹åŒ–ç’°å¢ƒç‰¹æ•ˆ
            createSnow();
            createMist();

            window.addEventListener('resize', onWindowResize);
            // åˆå§‹åŒ–éŸ³æ•ˆ
            window.addEventListener('click', initAudio, { once: true });
            window.addEventListener('touchstart', initAudio, { once: true });
        }

        // --- æ ¸å¿ƒæ©Ÿåˆ¶ï¼šè§¸ç™¼è”“å»¶äº‹ä»¶ ---
        function onSelect() {
            if (reticle.visible) {
                playIceSound(1.0); // æ’­æ”¾å¤§è²çš„åˆå§‹éŸ³æ•ˆ

                const spawnPos = new THREE.Vector3();
                const spawnQuat = new THREE.Quaternion();
                reticle.matrix.decompose(spawnPos, spawnQuat, new THREE.Vector3());

                // å‰µå»ºä¸€å€‹æ–°çš„ã€Œç”Ÿé•·äº‹ä»¶ã€ç‰©ä»¶
                const growthEvent = {
                    centerPos: spawnPos,     // ä¸­å¿ƒé»
                    orientation: spawnQuat,  // è¡¨é¢æ–¹å‘
                    radius: 0.1,            // ç•¶å‰æ“´æ•£åŠå¾‘
                    patchesCreated: 0,      // å·²ç”Ÿæˆçš„å†°å¡Šæ•¸
                    maxPatches: 12,         // ç¸½å…±è¦ç”Ÿæˆå¤šå°‘ç‰‡
                    lastSpawnTime: 0        // ä¸Šæ¬¡ç”Ÿæˆæ™‚é–“
                };
                growingIceEvents.push(growthEvent);
            }
        }

        // --- åœ¨æ¸²æŸ“å¾ªç’°ä¸­è™•ç†å†°éœœç”Ÿé•· ---
        function processIceGrowth(time) {
            // å€’åºéæ­·ä»¥ä¾¿å®‰å…¨ç§»é™¤å®Œæˆçš„äº‹ä»¶
            for (let i = growingIceEvents.length - 1; i >= 0; i--) {
                const event = growingIceEvents[i];

                // æ¯éš” 100ms ç”Ÿæˆä¸€ç‰‡æ–°çš„
                if (time - event.lastSpawnTime > 100) {
                    event.lastSpawnTime = time;

                    // 1. è¨ˆç®—æ–°å†°å¡Šç›¸å°æ–¼ä¸­å¿ƒçš„åç§»é‡ (åœ¨å¹³é¢ä¸Šéš¨æ©Ÿåˆ†ä½ˆ)
                    const angle = Math.random() * Math.PI * 2;
                    // åŠå¾‘éš¨æ©Ÿï¼Œä½†ç¸½é«”è¶¨å‹¢æ˜¯å‘å¤–æ“´æ•£
                    const dist = Math.random() * event.radius + (event.radius * 0.5);
                    const offset = new THREE.Vector3(Math.cos(angle) * dist, 0, Math.sin(angle) * dist);
                    
                    // é—œéµï¼šå°‡åç§»é‡æ ¹æ“šè¡¨é¢æ–¹å‘é€²è¡Œæ—‹è½‰
                    offset.applyQuaternion(event.orientation);
                    const finalPos = event.centerPos.clone().add(offset);

                    // 2. ç”Ÿæˆå†°å¡Š mesh
                    // è¶Šå¤–åœçš„å†°å¡Šç¨å¾®å°ä¸€é»
                    const scale = 1.0 - (event.patchesCreated / event.maxPatches) * 0.3;
                    spawnSingleIcePatch(finalPos, event.orientation, scale);
                    
                    // å¶çˆ¾æ’­æ”¾å°è²çš„ç¢è£‚éŸ³
                    if (Math.random() > 0.6) playIceSound(0.4);

                    // æ›´æ–°äº‹ä»¶ç‹€æ…‹
                    event.radius += 0.05; // æ“´å¤§åŠå¾‘
                    event.patchesCreated++;

                    // å¦‚æœç”Ÿæˆå®Œç•¢ï¼Œç§»é™¤äº‹ä»¶
                    if (event.patchesCreated >= event.maxPatches) {
                        growingIceEvents.splice(i, 1);
                    }
                }
            }
        }

        // --- ç”Ÿæˆå–®ä¸€å†°å¡Š Mesh ---
        function spawnSingleIcePatch(position, quaternion, scaleFactor) {
            // ç”Ÿæˆéš¨æ©Ÿä¸è¦å‰‡å½¢ç‹€
            const shape = new THREE.Shape();
            const points = 6 + Math.floor(Math.random() * 5);
            const rBase = 0.18 * scaleFactor;
            for(let i=0; i<points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const r = rBase * (0.7 + Math.random() * 0.6);
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                i === 0 ? shape.moveTo(x, y) : shape.lineTo(x, y);
            }
            shape.closePath();

            const geometry = new THREE.ShapeGeometry(shape);
            const material = new THREE.MeshPhongMaterial({
                map: iceTexture,
                transparent: true,
                opacity: 0, // åˆå§‹é€æ˜
                color: 0xddeeff,
                emissive: 0x3366ff,
                emissiveIntensity: 0.3,
                side: THREE.DoubleSide,
                depthWrite: false, // é¿å…é–ƒçˆ
                polygonOffset: true, // ARè²¼åœ–å¸¸ç”¨æŠ€å·§
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.quaternion.copy(quaternion);
            mesh.rotateX(-Math.PI / 2); // ä¿®æ­£ ShapeGeometry çš„æ–¹å‘
            mesh.rotateZ(Math.random() * Math.PI * 2);
            // ç¨å¾®æµ®èµ·ä¸€é»é»é¿å… Z-fighting
            mesh.translateZ(0.002);

            mesh.userData = { targetOpacity: 0.85 + Math.random() * 0.15 };
            scene.add(mesh);
            allIceMeshes.push(mesh);
        }

        // --- ç‰¹æ•ˆï¼šAR é›ªèŠ± ---
        function createSnow() {
            const geom = new THREE.BufferGeometry();
            const vertices = [];
            // åœ¨ç›¸æ©Ÿå‘¨åœè¼ƒå¤§ç¯„åœå…§ä¸‹é›ª
            for (let i = 0; i < 1000; i++) {
                vertices.push((Math.random() - 0.5) * 10); // x
                vertices.push(Math.random() * 5);          // y (é«˜åº¦)
                vertices.push((Math.random() - 0.5) * 10); // z
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const mat = new THREE.PointsMaterial({
                size: 0.04, color: 0xffffff, transparent: true, opacity: 0.7,
                map: mistTexture, blending: THREE.AdditiveBlending, depthWrite: false
            });
            snowSystem = new THREE.Points(geom, mat);
            scene.add(snowSystem);
        }

        // --- ç‰¹æ•ˆï¼šå¯’æ°£éœ§éœ¾ ---
        function createMist() {
            const geom = new THREE.BufferGeometry();
            const vertices = [];
            // éœ§æ°£é›†ä¸­åœ¨è¼ƒä½çš„ä½ç½®
            for (let i = 0; i < 300; i++) {
                vertices.push((Math.random() - 0.5) * 15);
                vertices.push(Math.random() * 2 - 1); // é è¿‘åœ°é¢
                vertices.push((Math.random() - 0.5) * 15);
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            // å„²å­˜éš¨æ©Ÿç§»å‹•é€Ÿåº¦
            const speeds = new Float32Array(vertices.length / 3);
            for(let i=0; i<speeds.length; i++) speeds[i] = 0.005 + Math.random()*0.01;
            geom.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));

            const mat = new THREE.PointsMaterial({
                size: 1.5, color: 0xaaccff, transparent: true, opacity: 0.2,
                map: mistTexture, blending: THREE.AdditiveBlending, depthWrite: false
            });
            mistSystem = new THREE.Points(geom, mat);
            scene.add(mistSystem);
        }

        // --- ç´‹ç†ç”Ÿæˆå™¨ (Canvas) ---
        function generateFrostTexture() {
            const c = document.createElement('canvas'); c.width=128; c.height=128;
            const ctx = c.getContext('2d'); ctx.clearRect(0,0,128,128);
            ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 1.5;
            for(let i=0; i<30; i++) { // å†°é‡
                ctx.beginPath(); ctx.moveTo(Math.random()*128, Math.random()*128);
                ctx.lineTo(Math.random()*128, Math.random()*128); ctx.stroke();
            }
            const g = ctx.createRadialGradient(64,64,20,64,64,64); // æŸ”å’Œé‚Šç·£
            g.addColorStop(0,'rgba(200,230,255,0.7)'); g.addColorStop(1,'rgba(255,255,255,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,128,128);
            return new THREE.CanvasTexture(c);
        }

        function generateMistTexture() { // æŸ”å’Œçš„åœ“å½¢éœ§æ°£
            const c = document.createElement('canvas'); c.width=64; c.height=64;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(32,32,0,32,32,32);
            g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(c);
        }

        // --- ç¨‹åºåŒ–éŸ³æ•ˆ ---
        function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); }
        function playIceSound(volume) {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            // ä½¿ç”¨é«˜é€šæ¿¾æ³¢å™¨è£½é€ å°–éŠ³çš„ç¢è£‚æ„Ÿ
            filter.type = 'highpass'; filter.frequency.value = 2000 + Math.random()*1000;
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(Math.random()*100 + 50, t); // éš¨æ©Ÿä½é »åº•å™ª
            // éŸ³é‡åŒ…çµ¡ï¼šç¬é–“è¡æ“Šå¾Œå¿«é€Ÿè¡°æ¸›
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(volume, t+0.01);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15 + Math.random()*0.2);
            osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(t + 0.5);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function render(timestamp, frame) {
            const time = performance.now();

            // 1. è™•ç†å†°éœœè”“å»¶
            processIceGrowth(time);

            // 2. æ›´æ–°æ‰€æœ‰å†°å¡Šçš„æ·¡å…¥å‹•ç•«
            allIceMeshes.forEach(mesh => {
                if (mesh.material.opacity < mesh.userData.targetOpacity) {
                    mesh.material.opacity += 0.08;
                }
            });

            // 3. æ›´æ–°é›ªèŠ±èˆ‡éœ§æ°£å‹•ç•«
            if (snowSystem) {
                const pos = snowSystem.geometry.attributes.position.array;
                for(let i=1; i<pos.length; i+=3) {
                    pos[i] -= 0.02; if(pos[i]<0) pos[i]=5;
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            if (mistSystem) {
                const pos = mistSystem.geometry.attributes.position.array;
                const speeds = mistSystem.geometry.attributes.speed.array;
                for(let i=0; i<pos.length; i+=3) {
                    pos[i] += Math.sin(time*0.001 + i)*speeds[i/3]; // X è»¸ç·©æ…¢æ“ºå‹•
                    pos[i+2] += Math.cos(time*0.001 + i)*speeds[i/3]; // Z è»¸ç·©æ…¢æ“ºå‹•
                }
                mistSystem.geometry.attributes.position.needsUpdate = true;
            }

            // 4. AR Hit-Test
            if (frame) {
                const refSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(refSpace => {
                        session.requestHitTestSource({ space: refSpace }).then(source => hitTestSource = source);
                    });
                    hitTestSourceRequested = true;
                }
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(refSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            renderer.render(scene, camera);
        }

        function animate() { renderer.setAnimationLoop(render); }
    </script>
</body>
</html>
