<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>真·AR 空間冰凍魔法</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        /* AR 按鈕樣式由 Three.js 自動生成，我們只需微調 */
        #ar-button-container {
            position: absolute; bottom: 20px; width: 100%; text-align: center; z-index: 100;
            pointer-events: none; /* 讓點擊穿透 */
        }
        #ar-button-container button {
             pointer-events: auto; /* 讓按鈕可點擊 */
             padding: 12px 24px; border: 1px solid rgb(255, 255, 255); border-radius: 4px; background: rgba(0, 0, 0, 0.5); color: rgb(255, 255, 255); font-size: 16px; cursor: pointer;
        }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center; color: #fff; 
            text-shadow: 0 0 5px #00f; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">請使用支援 WebXR 的手機瀏覽器<br>移動手機偵測平面，看到圓圈後點擊螢幕結冰</div>
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { ARButton } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/webxr/ARButton.js';

        let container;
        let camera, scene, renderer;
        let controller;
        
        let reticle; // 準心 (顯示平面偵測位置)
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        
        let snowSystem; // 雪花粒子系統

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            // WebXR 相機 (在 AR 模式下會自動被設備相機覆蓋)
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // 添加環境光，讓冰塊看起來亮一點
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            scene.add(light);

            // --- 渲染器設置 ---
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            // 關鍵：啟用 XR
            renderer.xr.enabled = true; 
            container.appendChild(renderer.domElement);

            // --- 添加 AR 啟動按鈕 ---
            // 這裡要求 'hit-test' 功能，這是抓取空間深度所必需的
            const arButton = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            document.body.appendChild(arButton);

            // --- 控制器 (處理點擊事件) ---
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect); // 當用戶點擊螢幕時觸發
            scene.add(controller);

            // --- 準心 (Reticle) ---
            // 這是一個小白圈，用來告訴用戶 AR 現在偵測到哪裡了
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ffff }) // 青色準心
            );
            reticle.matrixAutoUpdate = false; // 我們將手動更新它的位置
            reticle.visible = false; // 一開始隱藏，直到偵測到平面
            scene.add(reticle);

            // --- 創建 3D 雪花 ---
            createImmersiveSnow();

            window.addEventListener('resize', onWindowResize);
        }

        // --- 核心功能：點擊結冰 ---
        function onSelect() {
            // 只有當準心可見時 (代表偵測到平面)，點擊才有效
            if (reticle.visible) {
                // 創建一個冰塊貼圖 (使用 Shader 製造程序化冰紋理)
                // 這裡為了簡化，我們用一個半透明的青藍色平面加上噪點材質來模擬
                const iceMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaaddff, // 冰藍色
                    transparent: true,
                    opacity: 0.7,
                    shininess: 90,   // 高反光
                    side: THREE.DoubleSide,
                     // 簡單的噪點貼圖來增加質感 (這裡用 DataTexture 動態生成，避免外部檔案)
                    map: generateNoiseTexture() 
                });

                const iceGeometry = new THREE.CircleGeometry(0.5, 32); // 直徑 1 米的圓形冰塊
                const icePatch = new THREE.Mesh(iceGeometry, iceMaterial);
                
                // 將冰塊放置在準心當前的位置和方向
                icePatch.position.setFromMatrixPosition(reticle.matrix);
                icePatch.quaternion.setFromRotationMatrix(reticle.matrix);
                // 稍微旋轉一下冰塊，讓每次點擊看起來有點不同
                icePatch.rotation.z = Math.random() * Math.PI;

                scene.add(icePatch);
                
                // 可選：點擊時播放一個簡單的音效 (這裡省略，專注視覺)
            }
        }

        // --- 輔助函數：生成簡單的噪點紋理 ---
        function generateNoiseTexture() {
            const size = 64;
            const data = new Uint8Array(size * size * 4);
            for (let i = 0; i < size * size * 4; i += 4) {
                const val = Math.floor(Math.random() * 255);
                data[i] = val;     // R
                data[i + 1] = val + 50; // G (偏藍綠)
                data[i + 2] = 255; // B (藍色)
                data[i + 3] = Math.random() > 0.5 ? 200 : 100; // A (透明度變化)
            }
            const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
            texture.needsUpdate = true;
            return texture;
        }


        // --- 創建沉浸式 3D 雪花 ---
        function createImmersiveSnow() {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            
            // 在相機周圍 10x10x10 的空間內產生雪花
            for (let i = 0; i < particleCount; i++) {
                positions.push((Math.random() - 0.5) * 10); // x
                positions.push(Math.random() * 10);         // y (高度)
                positions.push((Math.random() - 0.5) * 10); // z
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.05,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 動畫循環 (XR 專用) ---
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            // 1. 更新雪花 (讓它們飄落)
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 1] -= 0.015; // 下落速度
                    // 如果掉到太下面，回到上面循環
                    if (positions[i * 3 + 1] < -2) {
                        positions[i * 3 + 1] = 8;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }

            // 2. 處理 AR Hit-Test (平面偵測)
            if (frame) {
                // 獲取參考空間
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                // 如果還沒請求過 Hit-Test 來源，現在請求
                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(function (referenceSpace) {
                        session.requestHitTestSource({ space: referenceSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });
                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                // 如果有 Hit-Test 來源，獲取測試結果
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        // 偵測到平面！
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        // 將準心移動到偵測到的位置和角度
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        // 沒偵測到平面
                        reticle.visible = false;
                    }
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
