<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AR æµé«”å†°çµé­”æ³•</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; color: #e0ffff; 
            text-shadow: 0 0 8px #00ffff; pointer-events: none; z-index: 10;
            background: rgba(0,0,0,0.5); padding: 15px 0;
        }
        /* éš±è—çš„å½±ç‰‡å…ƒç´  */
        #video-feed { position: absolute; top: 0; left: 0; display: none; }
    </style>
</head>
<body>
    <div id="info">
        <span style="font-size:1.4em; font-weight:bold">ğŸ§Š æµé«”å†°çµé­”æ³•</span><br>
        <small>å¾è¢å¹•ä¸‹æ–¹å¾€ä¸Šæ»‘å‹•ï¼Œæ–½æ”¾å†°éœœæµ</small>
    </div>

    <video id="video-feed" autoplay playsinline webkit-playsinline muted></video>
    
    <canvas id="mask-canvas" style="display:none;"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let camera, scene, renderer;
        let video, videoTexture;
        let maskCanvas, maskCtx, maskTexture;
        let iceMaterial, noiseTexture;
        let isDragging = false;
        let lastTouch = null;
        let audioCtx; // éŸ³æ•ˆ Context

        init();

        async function init() {
            // 1. å•Ÿå‹•ç›¸æ©Ÿ
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }, 
                    audio: false 
                });
                video = document.getElementById('video-feed');
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    video.play();
                    initThreeJS();
                };
            } catch (err) {
                alert("ç„¡æ³•é–‹å•Ÿç›¸æ©Ÿï¼Œè«‹ç¢ºèªæ¬Šé™æˆ–ä½¿ç”¨ HTTPSã€‚");
            }
        }

        function initThreeJS() {
            // --- åŸºç¤è¨­ç½® ---
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            // ä½¿ç”¨æ­£äº¤ç›¸æ©Ÿé€²è¡Œå…¨è¢å¹• 2D æ¸²æŸ“
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // --- ç´‹ç†æº–å‚™ ---
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;

            // å‰µå»ºç¨‹åºåŒ–å™ªè²ç´‹ç† (ç”¨æ–¼å†°éœœç´°ç¯€å’Œæµå‹•æ„Ÿ)
            noiseTexture = createNoiseTexture();

            // å‰µå»ºé®ç½©ç•«å¸ƒ (ç”¨æ–¼ç´€éŒ„æ‰‹å‹¢)
            maskCanvas = document.getElementById('mask-canvas');
            maskCanvas.width = window.innerWidth / 2; // é™ä½è§£æåº¦æå‡æ•ˆèƒ½
            maskCanvas.height = window.innerHeight / 2;
            maskCtx = maskCanvas.getContext('2d');
            maskCtx.fillStyle = 'black';
            maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskTexture = new THREE.CanvasTexture(maskCanvas);

            // --- æ ¸å¿ƒï¼šå†°éœœæµé«” Shader ---
            iceMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: videoTexture }, // åŸå§‹ç›¸æ©Ÿç•«é¢
                    tMask: { value: maskTexture },     // æ‰‹å‹¢é®ç½©
                    tNoise: { value: noiseTexture },   // å™ªè²ç´‹ç†
                    uTime: { value: 0 },               // æ™‚é–“ (ç”¨æ–¼æµå‹•å‹•ç•«)
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                // Vertex Shader (æ¨™æº–)
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                // Fragment Shader (æ ¸å¿ƒæ•ˆæœ)
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform sampler2D tMask;
                    uniform sampler2D tNoise;
                    uniform float uTime;
                    uniform vec2 uResolution;
                    varying vec2 vUv;

                    // å†°éœœé¡è‰²èª¿è‰²ç›¤
                    vec3 iceColorDark = vec3(0.1, 0.3, 0.5);
                    vec3 iceColorLight = vec3(0.6, 0.9, 1.0);

                    void main() {
                        vec4 original = texture2D(tDiffuse, vUv);
                        vec4 mask = texture2D(tMask, vUv);
                        
                        // 1. æ¡æ¨£å™ªè²ï¼ŒåŠ å…¥æ™‚é–“æµå‹•
                        float noise = texture2D(tNoise, vUv * 1.5 + vec2(0.0, uTime * 0.05)).r;
                        // ç¬¬äºŒå±¤å™ªè²å¢åŠ ç´°ç¯€
                        float detailNoise = texture2D(tNoise, vUv * 3.0 - vec2(uTime * 0.02, 0.0)).r;
                        
                        // 2. çµåˆé®ç½©å’Œå™ªè²ï¼Œå‰µé€ ä¸è¦å‰‡çš„æ“´æ•£é‚Šç·£
                        // mask.r æ˜¯æ‰‹æŒ‡æ»‘éçš„å€åŸŸå¼·åº¦
                        // æ¸›å»å™ªè²è®“é‚Šç·£è®Šå¾—ç ´ç¢ã€æœ‰çµæ™¶æ„Ÿ
                        float frostFactor = smoothstep(0.1, 0.6, mask.r * 1.5 + noise * 0.3 - detailNoise * 0.2);

                        // 3. å†°éœœæè³ªè¨ˆç®—
                        // æ ¹æ“šåŸå§‹ç•«é¢çš„äº®åº¦èª¿æ•´å†°éœœé¡è‰² (çœ‹èµ·ä¾†æ›´åƒé™„è‘—åœ¨ç‰©é«”ä¸Š)
                        float brightness = dot(original.rgb, vec3(0.299, 0.587, 0.114));
                        vec3 finalIceColor = mix(iceColorDark, iceColorLight, brightness + noise * 0.2);
                        
                        // å¢åŠ çµæ™¶é«˜å…‰
                        float specular = smoothstep(0.8, 1.0, noise * detailNoise + brightness * 0.3);
                        finalIceColor += vec3(specular) * 0.5;

                        // 4. æœ€çµ‚æ··åˆï¼šåŸå§‹ç•«é¢ vs å†°éœœç•«é¢
                        // ä½¿ç”¨ frostFactor ä½œç‚ºæ··åˆæ¬Šé‡
                        vec3 finalColor = mix(original.rgb, finalIceColor, frostFactor);

                        // å¢åŠ å†°éœœé‚Šç·£çš„æŠ˜å°„/ç™¼å…‰æ„Ÿ
                        float edge = smoothstep(0.0, 0.1, frostFactor) * (1.0 - smoothstep(0.9, 1.0, frostFactor));
                        finalColor += vec3(0.2, 0.5, 1.0) * edge * 0.3;

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            // å‰µå»ºä¸€å€‹è¦†è“‹å…¨è¢å¹•çš„å¹³é¢
            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, iceMaterial);
            scene.add(mesh);

            // --- äº‹ä»¶ç›£è½ ---
            window.addEventListener('resize', onWindowResize);
            // æ‰‹å‹¢æ“ä½œ
            window.addEventListener('touchstart', onTouchStart, { passive: false });
            window.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onTouchEnd);
            // éŸ³æ•ˆåˆå§‹åŒ–
            window.addEventListener('touchstart', initAudio, { once: true });

            animate();
        }

        // --- ç¨‹åºåŒ–å™ªè²ç´‹ç† ---
        function createNoiseTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(256, 256);
            for (let i = 0; i < imgData.data.length; i += 4) {
                const val = Math.floor(Math.random() * 255);
                imgData.data[i] = val;     // R
                imgData.data[i+1] = val;   // G
                imgData.data[i+2] = val;   // B
                imgData.data[i+3] = 255;   // A
            }
            ctx.putImageData(imgData, 0, 0);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- æ‰‹å‹¢è™•ç†ï¼šåœ¨é®ç½©ä¸Šç¹ªç•« ---
        function onTouchStart(e) {
            e.preventDefault();
            isDragging = true;
            lastTouch = getCanvasCoordinates(e.touches[0]);
            playIceSound(); // æ’­æ”¾éŸ³æ•ˆ
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (!isDragging) return;
            const currentTouch = getCanvasCoordinates(e.touches[0]);
            drawOnMask(lastTouch, currentTouch);
            lastTouch = currentTouch;
            if(Math.random() > 0.8) playIceSound(0.3 + Math.random()*0.3); // éš¨æ©Ÿæ’­æ”¾å°è²çš„ç¢è£‚éŸ³
        }

        function onTouchEnd() {
            isDragging = false;
        }

        function getCanvasCoordinates(touch) {
            // å°‡è§¸æ§åº§æ¨™è½‰æ›ç‚ºé®ç½©ç•«å¸ƒåº§æ¨™
            return {
                x: (touch.clientX / window.innerWidth) * maskCanvas.width,
                y: (touch.clientY / window.innerHeight) * maskCanvas.height
            };
        }

        function drawOnMask(start, end) {
            maskCtx.beginPath();
            maskCtx.moveTo(start.x, start.y);
            maskCtx.lineTo(end.x, end.y);
            maskCtx.strokeStyle = 'white'; // ç”¨ç™½è‰²ç¹ªè£½å†°éœœå€åŸŸ
            // ç­†åˆ·å¤§å°éš¨æ©Ÿè®ŠåŒ–ï¼Œæ¨¡æ“¬ä¸è¦å‰‡å™´å°„
            maskCtx.lineWidth = 30 + Math.random() * 20; 
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
            // ä½¿ç”¨æŸ”å’Œçš„ç­†è§¸
            maskCtx.shadowBlur = 20;
            maskCtx.shadowColor = 'white';
            maskCtx.stroke();
            // æ¨™è¨˜ç´‹ç†éœ€è¦æ›´æ–°
            maskTexture.needsUpdate = true;
        }

        // --- ç¨‹åºåŒ–éŸ³æ•ˆ ---
        function initAudio() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); }
        function playIceSound(volume = 0.8) {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = 3000 + Math.random()*2000; // æ›´é«˜é »ã€æ›´å°–éŠ³
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(Math.random()*50, t);
            gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(volume, t+0.005);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1 + Math.random()*0.2);
            osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(t + 0.4);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (iceMaterial) iceMaterial.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            // æ›´æ–° Shader æ™‚é–“åƒæ•¸ï¼Œè®“å™ªè²æµå‹•
            if (iceMaterial) iceMaterial.uniforms.uTime.value += 0.02;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
