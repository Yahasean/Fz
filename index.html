<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR å†°éœœæŠ•æ“²</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: sans-serif; }
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center; color: #fff; 
            text-shadow: 0 0 5px #00ffff; pointer-events: none; z-index: 10;
            background: rgba(0,0,0,0.4); padding: 10px 0;
        }
        #guide {
            position: absolute; bottom: 50px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.8); font-size: 1.2rem; pointer-events: none;
            animation: pulse 2s infinite; opacity: 0; transition: opacity 0.5s;
        }
        @keyframes pulse { 0% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(-10px); opacity: 1; } 100% { transform: translateY(0); opacity: 0.5; } }
    </style>
</head>
<body>
    <div id="info">
        <b>AR å†°éœœæŠ•æ“²</b><br>
        æ‰¾å°‹å¹³é¢é¡¯ç¤ºæº–å¿ƒå¾Œï¼Œ<span style="color:#00ffff">æ‰‹æŒ‡ä¸Šæ»‘</span> ç™¼å°„é­”æ³•
    </div>
    <div id="guide">ğŸ‘† å‘ä¸Šæ»‘å‹•ç™¼å°„</div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { ARButton } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/webxr/ARButton.js';

        let camera, scene, renderer;
        let reticle;
        let hitTestSource = null, hitTestSourceRequested = false;
        
        // éŠæˆ²ç‰©ä»¶ç®¡ç†
        const projectiles = []; // é£›è¡Œä¸­çš„å†°å½ˆ
        const icePatches = [];  // åœ°é¢ä¸Šçš„å†°éœœ
        let iceTexture;
        
        // æ‰‹å‹¢è®Šæ•¸
        let touchStartY = 0;
        let audioCtx;

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // ç‡ˆå…‰
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);
            const pointLight = new THREE.DirectionalLight(0xaabbff, 0.8);
            pointLight.position.set(0, 0, 0); // å…‰éš¨ç›¸æ©Ÿ
            camera.add(pointLight);
            scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

            // æº–å¿ƒ (ç„æº–ç”¨)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.12, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, opacity: 0.8, transparent: true })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // æè³ªç”Ÿæˆ
            iceTexture = generateIceTexture();

            // --- æ‰‹å‹¢ç›£è½ (Swipe) ---
            window.addEventListener('touchstart', (e) => {
                touchStartY = e.touches[0].clientY;
                initAudio(); // åˆå§‹åŒ–éŸ³æ•ˆ
            });
            
            window.addEventListener('touchend', (e) => {
                const touchEndY = e.changedTouches[0].clientY;
                const dist = touchStartY - touchEndY; // è¨ˆç®—æ»‘å‹•è·é›¢
                
                // å¦‚æœå‘ä¸Šæ»‘å‹•è·é›¢è¶…é 100px ä¸”æº–å¿ƒæœ‰ç„æº–åˆ°æ±è¥¿
                if (dist > 100 && reticle.visible) {
                    shootMagic();
                }
            });

            window.addEventListener('resize', onWindowResize);
        }

        // --- ç™¼å°„é­”æ³•é‚è¼¯ ---
        function shootMagic() {
            playCastSound(); // ç™¼å°„éŸ³æ•ˆ

            // 1. å»ºç«‹å†°å½ˆ
            const geometry = new THREE.IcosahedronGeometry(0.05, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0xccffff });
            const projectile = new THREE.Mesh(geometry, material);

            // å¢åŠ ç™¼å…‰æ‹–å°¾ (ç°¡å–®çš„ç²’å­æˆ–å…‰æšˆ)
            const glowGeo = new THREE.IcosahedronGeometry(0.08, 1);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            projectile.add(glow);

            // 2. è¨­å®šèµ·é» (ç›¸æ©Ÿå‰æ–¹ä¸‹æ–¹ä¸€é»é»ï¼Œæ¨¡æ“¬å¾æ‰‹ç™¼å‡º)
            // å°‡æ­¤ä½ç½®è½‰ç‚ºä¸–ç•Œåº§æ¨™
            const startPos = new THREE.Vector3(0, -0.2, -0.3).applyMatrix4(camera.matrixWorld);
            projectile.position.copy(startPos);

            // 3. è¨­å®šç›®æ¨™ (æº–å¿ƒä½ç½®)
            const targetPos = new THREE.Vector3();
            const targetQuat = new THREE.Quaternion();
            reticle.matrix.decompose(targetPos, targetQuat, new THREE.Vector3());

            // 4. è¨ˆç®—é£›è¡Œé€Ÿåº¦å‘é‡
            const velocity = new THREE.Vector3().subVectors(targetPos, startPos).normalize().multiplyScalar(0.15); // é€Ÿåº¦ 0.15

            // 5. å„²å­˜é£›è¡Œè³‡æ–™
            projectile.userData = {
                velocity: velocity,
                target: targetPos,
                targetQuat: targetQuat, // æ’æ“Šæ™‚è¦ç”¨çš„è¡¨é¢æ—‹è½‰
                life: 0
            };

            scene.add(projectile);
            projectiles.push(projectile);
        }

        // --- æ’æ“Šï¼šç”Ÿæˆæ“´æ•£å†°éœœ ---
        function createImpact(position, quaternion) {
            playFreezeSound(); // æ’æ“ŠéŸ³æ•ˆ

            // å‰µå»ºå†°éœœè²¼ç‰‡
            // ä½¿ç”¨å¹³é¢å¹¾ä½•é«”ï¼Œä½†é€é Shader æˆ–æè³ªå‹•ç•«ä¾†åšæ“´æ•£
            const geometry = new THREE.PlaneGeometry(1, 1, 32, 32); 
            
            // é€™è£¡æˆ‘å€‘ç”¨ä¸€å€‹ç°¡å–®çš„æŠ€å·§ï¼šæ”¹è®Šé ‚é»ä½ç½®ä¾†æ¨¡æ“¬ä¸è¦å‰‡æ“´æ•£
            const posAttribute = geometry.attributes.position;
            for(let i=0; i<posAttribute.count; i++) {
                const x = posAttribute.getX(i);
                const y = posAttribute.getY(i);
                // ç¨å¾®æ“¾å‹•ä¸€ä¸‹é ‚é»è®“å½¢ç‹€ä¸é‚£éº¼æ–¹æ­£
                const dist = Math.sqrt(x*x + y*y);
                if(dist > 0.4) {
                     posAttribute.setZ(i, (Math.random()-0.5)*0.05); // é‚Šç·£èµ·ä¼
                }
            }
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                map: iceTexture,
                transparent: true,
                opacity: 0.9,
                color: 0xccf0ff,
                emissive: 0x004488,
                emissiveIntensity: 0.5,
                side: THREE.DoubleSide,
                alphaTest: 0.1,
                polygonOffset: true,
                polygonOffsetFactor: -1
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.quaternion.copy(quaternion);
            mesh.rotateX(-Math.PI / 2); // è²¼åˆå¹³é¢
            mesh.rotateZ(Math.random() * Math.PI * 2);
            
            // åˆå§‹ç‹€æ…‹ï¼šå¾ˆå°
            mesh.scale.set(0.01, 0.01, 0.01);
            
            // æ“´æ•£åƒæ•¸
            mesh.userData = {
                targetScale: 0.8 + Math.random() * 0.5, // æœ€çµ‚å¤§å°éš¨æ©Ÿ
                growthSpeed: 0.08, // ç”Ÿé•·é€Ÿåº¦
                wobble: Math.random() // éš¨æ©Ÿæ³¢å‹•åƒæ•¸
            };

            scene.add(mesh);
            icePatches.push(mesh);

            // é¡å¤–ç‰¹æ•ˆï¼šæ’æ“Šç²’å­ç‚¸è£‚
            createExplosion(position);
        }

        function createExplosion(pos) {
            // ç°¡å–®çš„ç²’å­çˆ†ç‚¸
            const count = 20;
            const geo = new THREE.BufferGeometry();
            const verts = [];
            const vels = [];
            for(let i=0; i<count; i++) {
                verts.push(pos.x, pos.y, pos.z);
                vels.push( (Math.random()-0.5)*0.05, Math.random()*0.05, (Math.random()-0.5)*0.05 );
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
            geo.userData = { vels: vels };
            
            const mat = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff, transparent: true });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            
            // ç”¨ç°¡å–®çš„æ–¹å¼ç®¡ç†é€™å€‹çŸ­æš«ç‰¹æ•ˆï¼Œä¸æ”¾å…¥ä¸»å¾ªç’°
            const startTime = Date.now();
            function animateExplosion() {
                const now = Date.now();
                if(now - startTime > 500) { scene.remove(points); return; }
                
                const positions = points.geometry.attributes.position.array;
                const velocities = points.geometry.userData.vels;
                for(let i=0; i<count; i++) {
                    positions[i*3] += velocities[i*3];
                    positions[i*3+1] += velocities[i*3+1];
                    positions[i*3+2] += velocities[i*3+2];
                }
                points.geometry.attributes.position.needsUpdate = true;
                points.material.opacity -= 0.05;
                requestAnimationFrame(animateExplosion);
            }
            animateExplosion();
        }

        // --- ç´‹ç†ç”Ÿæˆ ---
        function generateIceTexture() {
            const c = document.createElement('canvas'); c.width=256; c.height=256;
            const ctx = c.getContext('2d');
            ctx.clearRect(0,0,256,256);
            
            // 1. æ”¾å°„ç‹€å†°æ™¶
            const cx = 128, cy = 128;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 2;
            for(let i=0; i<40; i++) {
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                const angle = Math.random() * Math.PI * 2;
                const len = 40 + Math.random() * 80;
                // ç•«å‡ºé–ƒé›»èˆ¬çš„æŠ˜ç·š
                let currX = cx, currY = cy;
                for(let j=0; j<5; j++) {
                    currX += Math.cos(angle + (Math.random()-0.5)) * (len/5);
                    currY += Math.sin(angle + (Math.random()-0.5)) * (len/5);
                    ctx.lineTo(currX, currY);
                }
                ctx.stroke();
            }

            // 2. é‚Šç·£æŸ”å…‰
            const grad = ctx.createRadialGradient(cx, cy, 20, cx, cy, 120);
            grad.addColorStop(0, 'rgba(200, 240, 255, 0.6)');
            grad.addColorStop(0.8, 'rgba(200, 240, 255, 0.3)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.globalCompositeOperation = 'source-over'; // æ··åˆ
            ctx.fillRect(0,0,256,256);

            return new THREE.CanvasTexture(c);
        }

        // --- éŸ³æ•ˆ ---
        function initAudio() { if(!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); } }
        
        function playCastSound() { // å’»~
            if(!audioCtx) return;
            const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
            osc.frequency.setValueAtTime(400, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.2);
            g.gain.setValueAtTime(0.3, audioCtx.currentTime); g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.connect(g); g.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime+0.3);
        }

        function playFreezeSound() { // å–€æ»‹
            if(!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for(let i=0; i<bufferSize; i++) data[i] = Math.random()*2-1;
            
            const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 2000;
            const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0.8, audioCtx.currentTime); 
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.4);
            
            noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
            noise.start();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function render(timestamp, frame) {
            // 1. AR Hit-Test (æ›´æ–°æº–å¿ƒ)
            if (frame) {
                const refSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();
                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(refSpace => {
                        session.requestHitTestSource({ space: refSpace }).then(source => hitTestSource = source);
                    });
                    hitTestSourceRequested = true;
                }
                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(refSpace).transform.matrix);
                        // é¡¯ç¤ºæ“ä½œæç¤º
                        document.getElementById('guide').style.opacity = 1;
                    } else {
                        reticle.visible = false;
                        document.getElementById('guide').style.opacity = 0;
                    }
                }
            }

            // 2. æ›´æ–°é£›è¡Œä¸­çš„å†°å½ˆ
            for(let i=projectiles.length-1; i>=0; i--) {
                const p = projectiles[i];
                p.position.add(p.userData.velocity);
                
                // æª¢æŸ¥æ˜¯å¦åˆ°é”ç›®æ¨™ (ç°¡å–®è·é›¢æª¢æ¸¬)
                if(p.position.distanceTo(p.userData.target) < 0.2) {
                    // å‘½ä¸­ï¼
                    createImpact(p.userData.target, p.userData.targetQuat);
                    scene.remove(p);
                    projectiles.splice(i, 1);
                } else if (p.position.distanceTo(camera.position) > 20) {
                    // é£›å¤ªé æ¶ˆå¤±
                    scene.remove(p);
                    projectiles.splice(i, 1);
                }
            }

            // 3. æ›´æ–°åœ°ä¸Šçš„å†°éœœ (æ“´æ•£å‹•ç•«)
            icePatches.forEach(ice => {
                if(ice.scale.x < ice.userData.targetScale) {
                    // åƒæ¶²é«”ä¸€æ¨£å¿«é€Ÿæ“´å¼µç„¶å¾Œæ¸›é€Ÿ
                    ice.userData.growthSpeed *= 0.95; 
                    const s = Math.min(ice.userData.growthSpeed + 0.005, 0.1); // æœ€å°é€Ÿåº¦
                    ice.scale.addScalar(s);
                    // æ“´æ•£æ™‚ç¨å¾®æ—‹è½‰ä¸€é»ï¼Œå¢åŠ æµå‹•æ„Ÿ
                    ice.rotation.z += 0.01; 
                }
            });

            renderer.render(scene, camera);
        }

        function animate() { renderer.setAnimationLoop(render); }
    </script>
</body>
</html>
